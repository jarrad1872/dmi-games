<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Core Drop ‚Äî DMI Tools</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #1a1a2e;
        }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 480px;
            max-height: 100vh;
            background: linear-gradient(180deg, #2d3436 0%, #636e72 50%, #b2bec3 100%);
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        /* UI Overlays */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            text-align: center;
            padding: 20px;
            z-index: 10;
        }
        
        .overlay.hidden {
            display: none;
        }
        
        .logo {
            font-size: 12px;
            color: #ff6b35;
            letter-spacing: 3px;
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        h1 {
            font-size: 42px;
            margin-bottom: 8px;
            color: #ffd700;
            text-shadow: 2px 2px 0 #8b4513;
        }
        
        .subtitle {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 30px;
        }
        
        .instructions {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 30px;
            max-width: 300px;
        }
        
        .instructions p {
            margin: 10px 0;
            font-size: 15px;
            line-height: 1.5;
        }
        
        .btn {
            background: linear-gradient(135deg, #ff6b35, #f7931e);
            color: white;
            border: none;
            padding: 18px 50px;
            font-size: 20px;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 6px 0 #cc4a1a, 0 8px 20px rgba(0,0,0,0.3);
            transition: transform 0.1s, box-shadow 0.1s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .btn:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #cc4a1a;
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #636e72, #4a5568);
            box-shadow: 0 6px 0 #2d3748, 0 8px 20px rgba(0,0,0,0.3);
            padding: 14px 35px;
            font-size: 16px;
            margin-top: 15px;
        }
        
        .btn-secondary:active {
            box-shadow: 0 2px 0 #2d3748;
        }
        
        .score-display {
            font-size: 64px;
            font-weight: bold;
            color: #ffd700;
            margin: 20px 0;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }
        
        .stats {
            display: flex;
            gap: 30px;
            margin: 20px 0;
            font-size: 14px;
        }
        
        .stats span {
            color: #aaa;
        }
        
        .stats strong {
            color: white;
        }
        
        .high-score {
            font-size: 13px;
            color: #888;
            margin-top: 10px;
        }
        
        /* HUD */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 5;
        }
        
        .hud-box {
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 14px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }
        
        .hud-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .hud-value {
            font-size: 22px;
            font-weight: bold;
            color: white;
        }
        
        #hudScore .hud-value { color: #ffd700; }
        #hudCombo { display: none; }
        #hudCombo.active { display: block; }
        #hudCombo .hud-value { color: #ff6b35; }
        
        /* Combo popup */
        #comboPopup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            font-size: 36px;
            font-weight: bold;
            color: #ff6b35;
            text-shadow: 0 0 20px #ff6b35, 2px 2px 0 #000;
            pointer-events: none;
            z-index: 5;
            opacity: 0;
            transition: none;
        }
        
        #comboPopup.show {
            animation: comboPop 0.5s ease-out forwards;
        }
        
        @keyframes comboPop {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            30% { transform: translate(-50%, -50%) scale(1.3); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }
        
        /* Sound toggle */
        #soundBtn {
            position: absolute;
            bottom: 15px;
            left: 15px;
            width: 44px;
            height: 44px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Damage indicator */
        #damageFlash {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle, rgba(255,0,0,0.4) 0%, transparent 70%);
            pointer-events: none;
            opacity: 0;
            z-index: 4;
        }
        
        #damageFlash.flash {
            animation: damageFlash 0.3s ease-out;
        }
        
        @keyframes damageFlash {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        /* Lives display */
        #lives {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            z-index: 5;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="game"></canvas>
        
        <!-- HUD -->
        <div id="hud">
            <div id="hudScore" class="hud-box">
                <div class="hud-label">Score</div>
                <div class="hud-value">0</div>
            </div>
            <div id="hudCombo" class="hud-box">
                <div class="hud-label">Combo</div>
                <div class="hud-value">x2</div>
            </div>
        </div>
        
        <div id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
        
        <div id="comboPopup">COMBO x2</div>
        <div id="damageFlash"></div>
        
        <button id="soundBtn">üîä</button>
        
        <!-- Start Screen -->
        <div id="startScreen" class="overlay">
            <div class="logo">‚öôÔ∏è DMI TOOLS ‚öôÔ∏è</div>
            <h1>CORE DROP</h1>
            <div class="subtitle">Catch the cores before they hit!</div>
            
            <div class="instructions">
                <p>üéØ <strong>Drag</strong> to move your catcher</p>
                <p>üß± <strong>Catch</strong> falling concrete cores</p>
                <p>üí• <strong>Miss 3</strong> and you're done!</p>
            </div>
            
            <button class="btn" id="startBtn">START</button>
            
            <div class="high-score">High Score: <span id="highScoreDisplay">0</span></div>
        </div>
        
        <!-- Game Over Screen -->
        <div id="gameOverScreen" class="overlay hidden">
            <div class="logo">‚öôÔ∏è DMI TOOLS ‚öôÔ∏è</div>
            <h1>GAME OVER</h1>
            
            <div class="score-display" id="finalScore">0</div>
            
            <div class="stats">
                <div><span>Cores Caught:</span> <strong id="coresCaught">0</strong></div>
                <div><span>Best Combo:</span> <strong id="bestCombo">0</strong>x</div>
            </div>
            
            <button class="btn" id="restartBtn">TRY AGAIN</button>
            <button class="btn btn-secondary" id="shareBtn">üì§ SHARE</button>
            
            <div class="high-score">High Score: <span id="highScoreDisplay2">0</span></div>
        </div>
    </div>
    
    <script>
    // ============================================
    // CORE DROP v2 - Phase 1 Prototype
    // ============================================
    
    // --- Audio Engine ---
    const Audio = {
        ctx: null,
        enabled: true,
        
        init() {
            try {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            } catch(e) {
                console.warn('Web Audio not supported');
            }
        },
        
        resume() {
            if (this.ctx?.state === 'suspended') this.ctx.resume();
        },
        
        play(type) {
            if (!this.enabled || !this.ctx) return;
            this.resume();
            
            const now = this.ctx.currentTime;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            
            switch(type) {
                case 'catch':
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                    osc.start(now);
                    osc.stop(now + 0.15);
                    break;
                    
                case 'perfect':
                    [523, 659, 784].forEach((freq, i) => {
                        const o = this.ctx.createOscillator();
                        const g = this.ctx.createGain();
                        o.connect(g);
                        g.connect(this.ctx.destination);
                        o.frequency.value = freq;
                        g.gain.setValueAtTime(0.2, now + i * 0.08);
                        g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.08 + 0.2);
                        o.start(now + i * 0.08);
                        o.stop(now + i * 0.08 + 0.2);
                    });
                    break;
                    
                case 'miss':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(150, now);
                    osc.frequency.exponentialRampToValueAtTime(50, now + 0.3);
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    osc.start(now);
                    osc.stop(now + 0.3);
                    break;
                    
                case 'combo':
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(600, now);
                    osc.frequency.exponentialRampToValueAtTime(1200, now + 0.15);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                    osc.start(now);
                    osc.stop(now + 0.2);
                    break;
                    
                case 'gameOver':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.exponentialRampToValueAtTime(30, now + 0.8);
                    gain.gain.setValueAtTime(0.4, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
                    osc.start(now);
                    osc.stop(now + 0.8);
                    break;
            }
        },
        
        toggle() {
            this.enabled = !this.enabled;
            return this.enabled;
        }
    };
    
    // --- Haptic Feedback ---
    function haptic(type = 'light') {
        if (!('vibrate' in navigator)) return;
        switch(type) {
            case 'light': navigator.vibrate(10); break;
            case 'medium': navigator.vibrate(25); break;
            case 'heavy': navigator.vibrate([50, 30, 50]); break;
        }
    }
    
    // --- Game State ---
    const game = {
        canvas: null,
        ctx: null,
        width: 0,
        height: 0,
        running: false,
        score: 0,
        highScore: 0,
        lives: 3,
        combo: 0,
        maxCombo: 0,
        coresCaught: 0,
        lastCatchTime: 0,
        comboWindow: 2000, // ms to maintain combo
        difficulty: 1,
        
        // Catcher
        catcher: {
            x: 0,
            y: 0,
            width: 80,
            height: 30,
            targetX: 0,
            speed: 0.15 // smoothing factor
        },
        
        // Cores
        cores: [],
        coreSpawnTimer: 0,
        coreSpawnInterval: 1500, // ms between spawns
        
        // Particles
        particles: [],
        
        // Touch
        touchX: null
    };
    
    // --- Core Class ---
    class Core {
        constructor(x, size) {
            this.x = x;
            this.y = -50;
            this.size = size; // 1=small, 2=medium, 3=large
            this.radius = 15 + size * 8;
            this.speed = 2 + Math.random() * 1 + game.difficulty * 0.5;
            this.rotation = Math.random() * Math.PI * 2;
            this.rotationSpeed = (Math.random() - 0.5) * 0.1;
            this.points = [10, 25, 50][size - 1];
            this.caught = false;
            this.missed = false;
        }
        
        update(dt) {
            this.y += this.speed * dt * 60;
            this.rotation += this.rotationSpeed;
        }
        
        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            
            // Outer ring (concrete)
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#888';
            ctx.fill();
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Inner ring (hollow core)
            ctx.beginPath();
            ctx.arc(0, 0, this.radius * 0.6, 0, Math.PI * 2);
            ctx.fillStyle = '#555';
            ctx.fill();
            
            // Aggregate texture
            for (let i = 0; i < 5 + this.size * 2; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = this.radius * 0.3 + Math.random() * this.radius * 0.5;
                const spotX = Math.cos(angle) * dist;
                const spotY = Math.sin(angle) * dist;
                ctx.beginPath();
                ctx.arc(spotX, spotY, 2 + Math.random() * 2, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(100, 100, 100, ${0.3 + Math.random() * 0.3})`;
                ctx.fill();
            }
            
            ctx.restore();
        }
    }
    
    // --- Particle Class ---
    class Particle {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.vx = (Math.random() - 0.5) * 8;
            this.vy = (Math.random() - 0.5) * 8 - 3;
            this.life = 1;
            this.decay = 0.02 + Math.random() * 0.02;
            this.size = 3 + Math.random() * 4;
            this.color = color;
        }
        
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += 0.2; // gravity
            this.life -= this.decay;
        }
        
        draw(ctx) {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
            ctx.fillStyle = this.color.replace('1)', `${this.life})`);
            ctx.fill();
        }
    }
    
    // --- Initialization ---
    function init() {
        game.canvas = document.getElementById('game');
        game.ctx = game.canvas.getContext('2d');
        
        resize();
        window.addEventListener('resize', resize);
        
        // Load high score
        game.highScore = parseInt(localStorage.getItem('coreDropHighScore') || '0');
        document.getElementById('highScoreDisplay').textContent = game.highScore;
        document.getElementById('highScoreDisplay2').textContent = game.highScore;
        
        // Input events
        setupInput();
        
        // Audio init on first interaction
        document.addEventListener('touchstart', () => Audio.init(), { once: true });
        document.addEventListener('click', () => Audio.init(), { once: true });
        
        // UI buttons
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', startGame);
        document.getElementById('shareBtn').addEventListener('click', shareScore);
        document.getElementById('soundBtn').addEventListener('click', toggleSound);
        
        // Draw initial state
        drawBackground();
    }
    
    function resize() {
        const container = document.getElementById('gameContainer');
        const dpr = window.devicePixelRatio || 1;
        
        game.width = container.clientWidth;
        game.height = container.clientHeight;
        
        game.canvas.width = game.width * dpr;
        game.canvas.height = game.height * dpr;
        game.ctx.scale(dpr, dpr);
        
        // Position catcher
        game.catcher.x = game.width / 2;
        game.catcher.targetX = game.width / 2;
        game.catcher.y = game.height - 80;
    }
    
    function setupInput() {
        const container = document.getElementById('gameContainer');
        
        // Touch
        container.addEventListener('touchstart', (e) => {
            if (!game.running) return;
            e.preventDefault();
            game.touchX = e.touches[0].clientX;
        }, { passive: false });
        
        container.addEventListener('touchmove', (e) => {
            if (!game.running) return;
            e.preventDefault();
            const rect = container.getBoundingClientRect();
            game.catcher.targetX = e.touches[0].clientX - rect.left;
        }, { passive: false });
        
        container.addEventListener('touchend', () => {
            game.touchX = null;
        });
        
        // Mouse (for desktop testing)
        container.addEventListener('mousemove', (e) => {
            if (!game.running) return;
            const rect = container.getBoundingClientRect();
            game.catcher.targetX = e.clientX - rect.left;
        });
    }
    
    // --- Game Loop ---
    let lastTime = 0;
    
    function gameLoop(timestamp) {
        if (!game.running) return;
        
        const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
        lastTime = timestamp;
        
        update(dt);
        draw();
        
        requestAnimationFrame(gameLoop);
    }
    
    function update(dt) {
        // Update catcher position (smooth movement)
        const dx = game.catcher.targetX - game.catcher.x;
        game.catcher.x += dx * game.catcher.speed * dt * 60;
        
        // Clamp to screen
        const halfWidth = game.catcher.width / 2;
        game.catcher.x = Math.max(halfWidth, Math.min(game.width - halfWidth, game.catcher.x));
        
        // Spawn cores
        game.coreSpawnTimer += dt * 1000;
        if (game.coreSpawnTimer >= game.coreSpawnInterval) {
            spawnCore();
            game.coreSpawnTimer = 0;
            
            // Increase difficulty over time
            game.difficulty += 0.02;
            game.coreSpawnInterval = Math.max(600, game.coreSpawnInterval - 10);
        }
        
        // Update cores
        for (let i = game.cores.length - 1; i >= 0; i--) {
            const core = game.cores[i];
            core.update(dt);
            
            // Check catch
            if (!core.caught && !core.missed) {
                const catcherTop = game.catcher.y - game.catcher.height / 2;
                const catcherBottom = game.catcher.y + game.catcher.height / 2;
                const catcherLeft = game.catcher.x - game.catcher.width / 2;
                const catcherRight = game.catcher.x + game.catcher.width / 2;
                
                if (core.y + core.radius > catcherTop && 
                    core.y - core.radius < catcherBottom &&
                    core.x > catcherLeft && 
                    core.x < catcherRight) {
                    catchCore(core);
                }
            }
            
            // Check miss
            if (!core.caught && core.y - core.radius > game.height) {
                missCore(core);
            }
            
            // Remove old cores
            if (core.y > game.height + 100 || core.caught) {
                game.cores.splice(i, 1);
            }
        }
        
        // Update particles
        for (let i = game.particles.length - 1; i >= 0; i--) {
            game.particles[i].update();
            if (game.particles[i].life <= 0) {
                game.particles.splice(i, 1);
            }
        }
        
        // Check combo timeout
        if (game.combo > 0 && Date.now() - game.lastCatchTime > game.comboWindow) {
            game.combo = 0;
            document.getElementById('hudCombo').classList.remove('active');
        }
    }
    
    function spawnCore() {
        const padding = 50;
        const x = padding + Math.random() * (game.width - padding * 2);
        const size = Math.random() < 0.6 ? 1 : (Math.random() < 0.7 ? 2 : 3);
        game.cores.push(new Core(x, size));
    }
    
    function catchCore(core) {
        core.caught = true;
        game.coresCaught++;
        
        // Combo
        game.combo++;
        game.lastCatchTime = Date.now();
        if (game.combo > game.maxCombo) game.maxCombo = game.combo;
        
        // Calculate points
        const comboMultiplier = Math.min(game.combo, 10);
        const points = core.points * comboMultiplier;
        game.score += points;
        
        // Perfect catch (center)
        const centerDist = Math.abs(core.x - game.catcher.x);
        const isPerfect = centerDist < 15;
        
        // Visual feedback
        if (isPerfect) {
            Audio.play('perfect');
            haptic('medium');
            spawnParticles(core.x, core.y, 20, 'rgba(255, 215, 0, 1)');
        } else {
            Audio.play('catch');
            haptic('light');
            spawnParticles(core.x, core.y, 10, 'rgba(255, 150, 50, 1)');
        }
        
        // Combo popup
        if (game.combo >= 2) {
            Audio.play('combo');
            showComboPopup(game.combo);
        }
        
        // Update HUD
        updateHUD();
    }
    
    function missCore(core) {
        core.missed = true;
        game.lives--;
        game.combo = 0;
        
        Audio.play('miss');
        haptic('heavy');
        
        // Flash screen
        const flash = document.getElementById('damageFlash');
        flash.classList.remove('flash');
        void flash.offsetWidth; // trigger reflow
        flash.classList.add('flash');
        
        // Update lives display
        updateLives();
        
        // Check game over
        if (game.lives <= 0) {
            endGame();
        }
    }
    
    function spawnParticles(x, y, count, color) {
        for (let i = 0; i < count; i++) {
            game.particles.push(new Particle(x, y, color));
        }
    }
    
    function showComboPopup(combo) {
        const popup = document.getElementById('comboPopup');
        popup.textContent = `COMBO x${combo}`;
        popup.classList.remove('show');
        void popup.offsetWidth;
        popup.classList.add('show');
        
        // Update HUD combo
        const hudCombo = document.getElementById('hudCombo');
        hudCombo.classList.add('active');
        hudCombo.querySelector('.hud-value').textContent = `x${combo}`;
    }
    
    function updateHUD() {
        document.getElementById('hudScore').querySelector('.hud-value').textContent = game.score;
    }
    
    function updateLives() {
        const hearts = '‚ù§Ô∏è'.repeat(game.lives) + 'üñ§'.repeat(3 - game.lives);
        document.getElementById('lives').textContent = hearts;
    }
    
    // --- Drawing ---
    function draw() {
        const ctx = game.ctx;
        
        // Clear
        drawBackground();
        
        // Draw drill at top
        drawDrill();
        
        // Draw cores
        game.cores.forEach(core => core.draw(ctx));
        
        // Draw particles
        game.particles.forEach(p => p.draw(ctx));
        
        // Draw catcher
        drawCatcher();
    }
    
    function drawBackground() {
        const ctx = game.ctx;
        
        // Sky/ceiling gradient
        const gradient = ctx.createLinearGradient(0, 0, 0, game.height);
        gradient.addColorStop(0, '#4a4a5a');
        gradient.addColorStop(0.3, '#5a5a6a');
        gradient.addColorStop(1, '#6a6a7a');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, game.width, game.height);
        
        // Floor
        ctx.fillStyle = '#3a3a4a';
        ctx.fillRect(0, game.height - 40, game.width, 40);
        
        // Grid lines (subtle)
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
        ctx.lineWidth = 1;
        for (let y = 0; y < game.height; y += 50) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(game.width, y);
            ctx.stroke();
        }
    }
    
    function drawDrill() {
        const ctx = game.ctx;
        const drillX = game.width / 2;
        const drillY = 30;
        
        // Motor housing
        ctx.fillStyle = '#ff6b35';
        ctx.fillRect(drillX - 30, drillY - 15, 60, 30);
        
        // Bit
        ctx.fillStyle = '#888';
        ctx.fillRect(drillX - 5, drillY + 15, 10, 40);
        
        // DMI logo
        ctx.fillStyle = 'white';
        ctx.font = 'bold 10px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('DMI', drillX, drillY + 4);
    }
    
    function drawCatcher() {
        const ctx = game.ctx;
        const c = game.catcher;
        
        // Glove/net base
        ctx.fillStyle = '#ff6b35';
        ctx.beginPath();
        ctx.roundRect(c.x - c.width/2, c.y - c.height/2, c.width, c.height, 10);
        ctx.fill();
        
        // Highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.beginPath();
        ctx.roundRect(c.x - c.width/2 + 5, c.y - c.height/2 + 3, c.width - 10, c.height/3, 5);
        ctx.fill();
        
        // Net lines
        ctx.strokeStyle = '#cc4a1a';
        ctx.lineWidth = 2;
        for (let i = 0; i < 4; i++) {
            const lineX = c.x - c.width/2 + (c.width / 4) * (i + 0.5);
            ctx.beginPath();
            ctx.moveTo(lineX, c.y - c.height/2 + 5);
            ctx.lineTo(lineX, c.y + c.height/2 - 5);
            ctx.stroke();
        }
    }
    
    // --- Game State ---
    function startGame() {
        // Reset state
        game.running = true;
        game.score = 0;
        game.lives = 3;
        game.combo = 0;
        game.maxCombo = 0;
        game.coresCaught = 0;
        game.difficulty = 1;
        game.coreSpawnInterval = 1500;
        game.coreSpawnTimer = 0;
        game.cores = [];
        game.particles = [];
        
        // Reset catcher position
        game.catcher.x = game.width / 2;
        game.catcher.targetX = game.width / 2;
        
        // Update UI
        updateHUD();
        updateLives();
        document.getElementById('hudCombo').classList.remove('active');
        
        // Hide overlays
        document.getElementById('startScreen').classList.add('hidden');
        document.getElementById('gameOverScreen').classList.add('hidden');
        
        // Start loop
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
    }
    
    function endGame() {
        game.running = false;
        
        Audio.play('gameOver');
        haptic('heavy');
        
        // Check high score
        if (game.score > game.highScore) {
            game.highScore = game.score;
            localStorage.setItem('coreDropHighScore', game.highScore.toString());
        }
        
        // Update game over screen
        document.getElementById('finalScore').textContent = game.score;
        document.getElementById('coresCaught').textContent = game.coresCaught;
        document.getElementById('bestCombo').textContent = game.maxCombo;
        document.getElementById('highScoreDisplay2').textContent = game.highScore;
        
        // Show game over
        setTimeout(() => {
            document.getElementById('gameOverScreen').classList.remove('hidden');
        }, 500);
    }
    
    function toggleSound() {
        const enabled = Audio.toggle();
        document.getElementById('soundBtn').textContent = enabled ? 'üîä' : 'üîá';
    }
    
    function shareScore() {
        const text = `I scored ${game.score} points in Core Drop by DMI Tools! üß±‚õèÔ∏è\n\nCan you beat my score?`;
        
        if (navigator.share) {
            navigator.share({
                title: 'Core Drop ‚Äî DMI Tools',
                text: text,
                url: window.location.href
            }).catch(() => {});
        } else {
            // Fallback: copy to clipboard
            navigator.clipboard.writeText(text + '\n' + window.location.href);
            alert('Score copied to clipboard!');
        }
    }
    
    // --- Start ---
    window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
