<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>{{TITLE}} | DMI Tools</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: {{BG_COLOR}}; 
      overflow: hidden;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      touch-action: manipulation;
    }
    #game-container { 
      width: 100vw; 
      height: 100vh; 
      display: flex; 
      align-items: center; 
      justify-content: center;
    }
    canvas { max-width: 100%; max-height: 100%; }
    .cta-button {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, {{PRIMARY_COLOR}} 0%, {{SECONDARY_COLOR}} 100%);
      color: white;
      padding: 14px 36px;
      border-radius: 30px;
      font-weight: 700;
      text-decoration: none;
      font-size: 16px;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
      transition: all 0.3s ease;
    }
    .cta-button:hover { transform: translateX(-50%) translateY(-2px) scale(1.02); }
    .branding {
      position: fixed;
      top: 12px;
      left: 12px;
      color: white;
      font-size: 13px;
      font-weight: 600;
      z-index: 1000;
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(0,0,0,0.4);
      padding: 8px 14px;
      border-radius: 20px;
      backdrop-filter: blur(10px);
    }
    .branding-icon {
      width: 24px;
      height: 24px;
      background: linear-gradient(135deg, {{PRIMARY_COLOR}}, {{SECONDARY_COLOR}});
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
  </style>
</head>
<body>
  <div id="game-container"></div>
  {{#SHOW_BRANDING}}
  <div class="branding">
    <div class="branding-icon">‚öôÔ∏è</div>
    <span>DMI Tools Corp</span>
  </div>
  {{/SHOW_BRANDING}}
  <a href="{{CTA_URL}}" target="_blank" rel="noopener" class="cta-button">{{CTA_TEXT}}</a>
  
  <script>
    const CONFIG = {
      title: '{{TITLE}}',
      products: {{PRODUCTS_JSON}},
      theme: {
        primary: '{{PRIMARY_COLOR}}',
        secondary: '{{SECONDARY_COLOR}}',
        bg: '{{BG_COLOR}}'
      },
      difficulty: {{DIFFICULTY}},
      showBranding: {{SHOW_BRANDING}}
    };

    class BootScene extends Phaser.Scene {
      constructor() { super({ key: 'BootScene' }); }

      preload() {
        const { width, height } = this.scale;
        const barWidth = 300, barHeight = 20;
        const barX = (width - barWidth) / 2, barY = height / 2;
        
        const progressBar = this.add.graphics();
        const progressBox = this.add.graphics();
        progressBox.fillStyle(0x222222, 0.8);
        progressBox.fillRoundedRect(barX, barY, barWidth, barHeight, 10);
        
        this.load.on('progress', (value) => {
          progressBar.clear();
          progressBar.fillStyle(parseInt(CONFIG.theme.primary.replace('#', ''), 16), 1);
          progressBar.fillRoundedRect(barX + 4, barY + 4, (barWidth - 8) * value, barHeight - 8, 6);
        });
      }

      create() {
        this.createTextures();
        this.scene.start('GameScene');
      }

      createTextures() {
        const primaryColor = parseInt(CONFIG.theme.primary.replace('#', ''), 16);
        const secondaryColor = parseInt(CONFIG.theme.secondary.replace('#', ''), 16);

        // Player
        const playerGfx = this.make.graphics({ add: false });
        playerGfx.fillStyle(primaryColor);
        playerGfx.fillRoundedRect(10, 0, 30, 50, 8);
        playerGfx.fillCircle(25, -10, 14);
        playerGfx.fillStyle(0xffffff, 0.3);
        playerGfx.fillRoundedRect(15, 5, 8, 35, 4);
        playerGfx.generateTexture('player', 50, 70);

        // Ground
        const groundGfx = this.make.graphics({ add: false });
        groundGfx.fillStyle(secondaryColor);
        groundGfx.fillRect(0, 0, 100, 40);
        groundGfx.fillStyle(0x000000, 0.2);
        groundGfx.fillRect(0, 35, 100, 5);
        groundGfx.generateTexture('ground', 100, 40);

        // Obstacle
        const obstacleGfx = this.make.graphics({ add: false });
        obstacleGfx.fillStyle(0xFF3B3B);
        obstacleGfx.fillTriangle(30, 0, 0, 60, 60, 60);
        obstacleGfx.fillStyle(0xffffff, 0.3);
        obstacleGfx.fillTriangle(30, 10, 15, 50, 30, 50);
        obstacleGfx.generateTexture('obstacle', 60, 60);

        // Coin
        const coinGfx = this.make.graphics({ add: false });
        coinGfx.fillStyle(0xFFD700);
        coinGfx.fillCircle(18, 18, 18);
        coinGfx.fillStyle(0xffffff, 0.4);
        coinGfx.fillCircle(14, 14, 6);
        coinGfx.generateTexture('coin', 36, 36);
      }
    }

    class GameScene extends Phaser.Scene {
      constructor() {
        super({ key: 'GameScene' });
        this.score = 0;
        this.gameOver = false;
        this.started = false;
        this.distance = 0;
        this.highScore = parseInt(localStorage.getItem('dmi-runner-highscore') || '0');
      }

      create() {
        const { width, height } = this.scale;
        
        const bg = this.add.graphics();
        bg.fillGradientStyle(
          parseInt(CONFIG.theme.bg.replace('#', ''), 16),
          parseInt(CONFIG.theme.bg.replace('#', ''), 16),
          0x000000, 0x000000
        );
        bg.fillRect(0, 0, width, height);

        for (let i = 0; i < 30; i++) {
          const dot = this.add.circle(
            Phaser.Math.Between(0, width),
            Phaser.Math.Between(0, height - 100),
            Phaser.Math.Between(1, 2), 0xffffff, 0.15
          );
          this.tweens.add({
            targets: dot, x: -20,
            duration: Phaser.Math.Between(4000, 8000),
            repeat: -1,
            onRepeat: () => { dot.x = width + 20; }
          });
        }

        this.ground = this.physics.add.staticGroup();
        for (let x = 0; x < width + 200; x += 100) {
          this.ground.create(x + 50, height - 20, 'ground');
        }

        this.player = this.physics.add.sprite(120, height - 90, 'player');
        this.player.setCollideWorldBounds(true);
        this.player.setOrigin(0.5, 1);
        this.physics.add.collider(this.player, this.ground);

        this.obstacles = this.physics.add.group();
        this.coins = this.physics.add.group();

        this.titleText = this.add.text(width/2, 50, CONFIG.title, {
          fontSize: '32px', fontFamily: 'Inter, sans-serif',
          fill: '#ffffff', fontStyle: 'bold'
        }).setOrigin(0.5);

        if (CONFIG.products.length > 0) {
          this.add.text(width/2, 90, CONFIG.products.map(p => p.icon).join('  '), 
            { fontSize: '24px' }).setOrigin(0.5);
        }

        this.startPrompt = this.add.text(width/2, height/2, 'üëÜ TAP TO JUMP', {
          fontSize: '22px', fontFamily: 'Inter, sans-serif',
          fill: '#ffffff', fontStyle: 'bold'
        }).setOrigin(0.5);

        this.tweens.add({
          targets: this.startPrompt,
          scale: 1.1, alpha: 0.7, duration: 800,
          yoyo: true, repeat: -1
        });

        this.scoreText = this.add.text(width/2, 50, '0', {
          fontSize: '64px', fontFamily: 'Inter, sans-serif',
          fill: '#ffffff', fontStyle: 'bold'
        }).setOrigin(0.5).setAlpha(0);

        this.distanceText = this.add.text(20, 100, '0m', {
          fontSize: '18px', fontFamily: 'Inter, sans-serif', fill: '#888888'
        }).setAlpha(0);

        this.input.on('pointerdown', () => this.jump());
        this.input.keyboard.on('keydown-SPACE', () => this.jump());

        this.physics.add.collider(this.player, this.obstacles, () => this.hitObstacle());
        this.physics.add.overlap(this.player, this.coins, (p, c) => this.collectCoin(c));

        this.spawnTimer = this.time.addEvent({
          delay: Math.max(1000, 1600 - (CONFIG.difficulty * 60)),
          callback: this.spawnObstacle, callbackScope: this,
          loop: true, paused: true
        });

        this.scoreTimer = this.time.addEvent({
          delay: 100,
          callback: () => {
            if (this.started && !this.gameOver) {
              this.distance += 5;
              this.score = Math.floor(this.distance / 10);
              this.scoreText.setText(this.score.toString());
              this.distanceText.setText(this.distance + 'm');
            }
          },
          loop: true, paused: true
        });

        this.tweens.add({
          targets: this.player, y: this.player.y - 5,
          duration: 400, yoyo: true, repeat: -1, ease: 'Sine.easeInOut'
        });
      }

      jump() {
        if (this.gameOver) {
          this.score = 0; this.distance = 0;
          this.scene.restart();
          return;
        }

        if (!this.started) {
          this.started = true;
          this.spawnTimer.paused = false;
          this.scoreTimer.paused = false;
          this.titleText.setAlpha(0);
          this.startPrompt.setVisible(false);
          this.scoreText.setAlpha(1);
          this.distanceText.setAlpha(1);
          this.tweens.killTweensOf(this.player);
        }

        if (this.player.body.touching.down) {
          this.player.setVelocityY(-500);
          this.tweens.add({
            targets: this.player,
            scaleX: 0.8, scaleY: 1.2, duration: 100, yoyo: true
          });
        }
      }

      spawnObstacle() {
        const { width, height } = this.scale;
        const speed = -350 - (CONFIG.difficulty * 25);
        
        const obstacle = this.obstacles.create(width + 30, height - 80, 'obstacle');
        obstacle.body.setAllowGravity(false);
        obstacle.setVelocityX(speed);
        obstacle.setImmovable(true);
        obstacle.setOrigin(0.5, 1);

        if (CONFIG.difficulty > 5 && Math.random() > 0.7) {
          const obstacle2 = this.obstacles.create(width + 90, height - 80, 'obstacle');
          obstacle2.body.setAllowGravity(false);
          obstacle2.setVelocityX(speed);
          obstacle2.setImmovable(true);
          obstacle2.setOrigin(0.5, 1);
        }

        if (Math.random() > 0.4) {
          const coinY = height - 150 - Math.random() * 120;
          const coin = this.coins.create(width + 150, coinY, 'coin');
          coin.body.setAllowGravity(false);
          coin.setVelocityX(speed);
          coin.setScale(0.9);
          this.tweens.add({
            targets: coin, y: coin.y - 15,
            duration: 400, yoyo: true, repeat: -1
          });
        }
      }

      collectCoin(coin) {
        for (let i = 0; i < 6; i++) {
          const particle = this.add.circle(coin.x, coin.y, 4, 0xFFD700);
          this.tweens.add({
            targets: particle,
            x: particle.x + Phaser.Math.Between(-40, 40),
            y: particle.y + Phaser.Math.Between(-40, 40),
            alpha: 0, scale: 0, duration: 300,
            onComplete: () => particle.destroy()
          });
        }
        
        coin.destroy();
        this.distance += 50;
        
        const popup = this.add.text(coin.x, coin.y, '+50', {
          fontSize: '20px', fontFamily: 'Inter, sans-serif',
          fill: '#FFD700', fontStyle: 'bold'
        }).setOrigin(0.5);
        
        this.tweens.add({
          targets: popup, y: popup.y - 40, alpha: 0,
          duration: 600, onComplete: () => popup.destroy()
        });
      }

      hitObstacle() {
        if (this.gameOver) return;
        this.gameOver = true;
        this.physics.pause();
        this.spawnTimer.paused = true;
        this.scoreTimer.paused = true;

        this.cameras.main.shake(200, 0.015);
        this.cameras.main.flash(200, 255, 0, 0, false);

        if (this.score > this.highScore) {
          this.highScore = this.score;
          localStorage.setItem('dmi-runner-highscore', this.highScore.toString());
        }

        const { width, height } = this.scale;
        
        const panel = this.add.graphics();
        panel.fillStyle(0x000000, 0.85);
        panel.fillRoundedRect(width/2 - 140, height/2 - 110, 280, 220, 20);

        this.add.text(width/2, height/2 - 70, 'GAME OVER', {
          fontSize: '32px', fontFamily: 'Inter, sans-serif',
          fill: '#ffffff', fontStyle: 'bold'
        }).setOrigin(0.5);

        this.add.text(width/2, height/2 - 20, 'Score: ' + this.score, {
          fontSize: '24px', fontFamily: 'Inter, sans-serif', fill: CONFIG.theme.primary
        }).setOrigin(0.5);

        this.add.text(width/2, height/2 + 15, 'Distance: ' + this.distance + 'm', {
          fontSize: '16px', fontFamily: 'Inter, sans-serif', fill: '#aaaaaa'
        }).setOrigin(0.5);

        this.add.text(width/2, height/2 + 45, 'Best: ' + this.highScore, {
          fontSize: '16px', fontFamily: 'Inter, sans-serif', fill: '#888888'
        }).setOrigin(0.5);

        const restartBtn = this.add.text(width/2, height/2 + 85, '‚Üª TAP TO RESTART', {
          fontSize: '16px', fontFamily: 'Inter, sans-serif',
          fill: '#ffffff', fontStyle: 'bold'
        }).setOrigin(0.5);

        this.tweens.add({
          targets: restartBtn, alpha: 0.5, duration: 600, yoyo: true, repeat: -1
        });
      }

      update() {
        if (this.started && !this.gameOver) {
          this.obstacles.getChildren().forEach(o => { if (o.x < -60) o.destroy(); });
          this.coins.getChildren().forEach(c => { if (c.x < -40) c.destroy(); });
          
          if (this.player.body.touching.down && this.player.body.velocity.y === 0) {
            if (this.player.scaleY > 1) {
              this.player.setScale(1.1, 0.9);
              this.tweens.add({
                targets: this.player, scaleX: 1, scaleY: 1, duration: 100
              });
            }
          }
        }
      }
    }

    const game = new Phaser.Game({
      type: Phaser.AUTO,
      parent: 'game-container',
      width: 400,
      height: 700,
      scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
      physics: {
        default: 'arcade',
        arcade: { gravity: { y: 1200 }, debug: false }
      },
      scene: [BootScene, GameScene],
      render: { antialias: true, roundPixels: true }
    });
  </script>
</body>
</html>
